package core

import (
	"errors"
	"machine"
)

// TMC5240Backend implements StepperBackend and PositionMover for TMC5240 stepper driver
// TMC5240 is SPI-controlled only and uses its internal motion controller
// It does NOT support traditional step/dir input mode like TMC2209
type TMC5240Backend struct {
	// SPI configuration
	spi   machine.SPI
	csPin machine.Pin

	// Configuration
	invertDir bool // Motor direction inversion (via GCONF.SHAFT bit)

	// Position tracking
	currentPos int64 // Current position (updated from XACTUAL)
	targetPos  int64 // Target position for current move

	// Velocity and acceleration parameters (stored for conversion)
	currentVel uint32
	maxVel     uint32
	accel      uint32

	// Status flags
	isInitialized bool
	hasError      bool
	errorCode     uint32
}

// NewTMC5240Backend creates a new TMC5240 backend
// spi: Configured SPI interface
// csPin: Chip select pin for this TMC5240
// NOTE: TMC5240 uses SPI control only, not step/dir inputs
func NewTMC5240Backend(spi machine.SPI, csPin machine.Pin) *TMC5240Backend {
	return &TMC5240Backend{
		spi:   spi,
		csPin: csPin,
	}
}

// Init initializes the TMC5240 hardware
// Implements StepperBackend.Init
// Note: stepPin and dirPin are ignored since TMC5240 is SPI-controlled
func (t *TMC5240Backend) Init(stepPin, dirPin uint8, invertStep, invertDir bool) error {
	t.invertDir = invertDir
	// Note: stepPin, dirPin, invertStep are ignored - TMC5240 uses SPI control only

	// Configure chip select pin
	t.csPin.Configure(machine.PinConfig{Mode: machine.PinOutput})
	t.csPin.High() // CS is active low

	// Initialize TMC5240 via SPI
	if err := t.initTMC5240Registers(); err != nil {
		return err
	}

	t.isInitialized = true
	return nil
}

// initTMC5240Registers configures TMC5240 registers for operation
func (t *TMC5240Backend) initTMC5240Registers() error {
	// Clear GSTAT to reset error flags
	if err := t.writeRegister(TMC5240_GSTAT, 0x07); err != nil {
		return err
	}

	// Configure GCONF - Enable StealthChop PWM mode
	var gconf uint32 = TMC5240_GCONF_EN_PWM_MODE // Enable StealthChop
	if t.invertDir {
		gconf |= TMC5240_GCONF_SHAFT // Invert motor direction
	}
	if err := t.writeRegister(TMC5240_GCONF, gconf); err != nil {
		return err
	}

	// Configure current (IHOLD_IRUN)
	// Format: IHOLD[4:0] | IRUN[12:8] | IHOLDDELAY[19:16]
	iholdIrun := uint32(TMC5240_IHOLD_DEFAULT) |
		(uint32(TMC5240_IRUN_DEFAULT) << 8) |
		(uint32(TMC5240_IHOLDDELAY_DEFAULT) << 16)
	if err := t.writeRegister(TMC5240_IHOLD_IRUN, iholdIrun); err != nil {
		return err
	}

	// Configure chopper (CHOPCONF)
	if err := t.writeRegister(TMC5240_CHOPCONF, TMC5240_CHOPCONF_DEFAULT); err != nil {
		return err
	}

	// Configure PWM (PWMCONF) for StealthChop
	if err := t.writeRegister(TMC5240_PWMCONF, TMC5240_PWMCONF_DEFAULT); err != nil {
		return err
	}

	// Initialize ramp generator (even in step/dir mode for future use)
	// Set position to 0
	if err := t.writeRegister(TMC5240_XACTUAL, 0); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_XTARGET, 0); err != nil {
		return err
	}

	// Set default velocities and accelerations
	if err := t.writeRegister(TMC5240_VSTART, 1); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_VSTOP, 10); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_V1, 50000); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_VMAX, 200000); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_AMAX, 10000); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_A1, 5000); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_DMAX, 10000); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_D1, 5000); err != nil {
		return err
	}

	// Set ramp mode to positioning
	if err := t.writeRegister(TMC5240_RAMPMODE, TMC5240_MODE_POSITION); err != nil {
		return err
	}

	return nil
}

// Step generates a single step pulse
// Implements StepperBackend.Step
// NOTE: TMC5240 generates steps internally via SPI commands, not external pulses
// This method is a no-op for TMC5240
func (t *TMC5240Backend) Step() {
	// TMC5240 uses internal motion controller - steps are generated by hardware
	// This method should not be called when using move_to_position
	// If queue_step is used, it will be converted to move_to_position by Stepper.MoveToPosition
}

// SetDirection sets the direction output
// Implements StepperBackend.SetDirection
// NOTE: TMC5240 direction is controlled by XTARGET sign, not GPIO
func (t *TMC5240Backend) SetDirection(dir bool) {
	// TMC5240 uses signed XTARGET for direction
	// Direction is determined by move_to_position command, not GPIO
	// This method is a no-op for TMC5240
}

// Stop immediately halts stepping
// Implements StepperBackend.Stop
func (t *TMC5240Backend) Stop() {
	// Set ramp mode to HOLD to stop motion immediately
	t.writeRegister(TMC5240_RAMPMODE, TMC5240_MODE_HOLD)
}

// GetName returns backend implementation name
// Implements StepperBackend.GetName
func (t *TMC5240Backend) GetName() string {
	return "TMC5240-SPI"
}

// writeRegister writes a 32-bit value to a TMC5240 register
func (t *TMC5240Backend) writeRegister(addr uint8, value uint32) error {
	// TMC5240 SPI protocol: [ADDR|WRITE_BIT][DATA3][DATA2][DATA1][DATA0]
	txBuf := []byte{
		addr | TMC5240_WRITE_BIT,
		uint8(value >> 24),
		uint8(value >> 16),
		uint8(value >> 8),
		uint8(value),
	}
	rxBuf := make([]byte, 5)

	// Chip select low
	t.csPin.Low()

	// Transfer
	err := t.spi.Tx(txBuf, rxBuf)

	// Chip select high
	t.csPin.High()

	return err
}

// readRegister reads a 32-bit value from a TMC5240 register
func (t *TMC5240Backend) readRegister(addr uint8) (uint32, error) {
	// TMC5240 requires two transactions: write address, then read data
	// First transaction: send read address
	txBuf1 := []byte{addr & 0x7F, 0, 0, 0, 0} // Clear write bit
	rxBuf1 := make([]byte, 5)

	t.csPin.Low()
	err := t.spi.Tx(txBuf1, rxBuf1)
	t.csPin.High()

	if err != nil {
		return 0, err
	}

	// Small delay between transactions
	for i := 0; i < 10; i++ {
		// NOP
	}

	// Second transaction: read the data
	txBuf2 := []byte{addr & 0x7F, 0, 0, 0, 0}
	rxBuf2 := make([]byte, 5)

	t.csPin.Low()
	err = t.spi.Tx(txBuf2, rxBuf2)
	t.csPin.High()

	if err != nil {
		return 0, err
	}

	// Combine bytes into 32-bit value
	value := uint32(rxBuf2[1])<<24 | uint32(rxBuf2[2])<<16 |
		uint32(rxBuf2[3])<<8 | uint32(rxBuf2[4])

	return value, nil
}

// --- PositionMover Interface Implementation ---

// MoveToPosition commands the TMC5240 to move to an absolute position
// Implements PositionMover.MoveToPosition
func (t *TMC5240Backend) MoveToPosition(targetPos int64, startVel, endVel, accel uint32) error {
	if !t.isInitialized {
		return errors.New("TMC5240 not initialized")
	}

	// Store parameters
	t.targetPos = targetPos
	t.maxVel = endVel
	t.accel = accel

	// Convert Klipper parameters to TMC5240 format
	// Klipper uses: interval (timer ticks between steps)
	// TMC5240 uses: velocity in Hz, scaled by 2^24 / fCLK

	// Convert startVel from interval to velocity
	// velocity_hz = TIMER_FREQ / interval
	// TMC5240_velocity = velocity_hz * 2^24 / fCLK
	vstart := t.intervalToTMCVelocity(startVel)
	vmax := t.intervalToTMCVelocity(endVel)
	amax := t.accelToTMCAccel(accel)

	// Set velocities
	if err := t.writeRegister(TMC5240_VSTART, vstart); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_VMAX, vmax); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_AMAX, amax); err != nil {
		return err
	}
	if err := t.writeRegister(TMC5240_DMAX, amax); err != nil { // Use same for decel
		return err
	}

	// Set target position (signed 32-bit)
	if err := t.writeRegister(TMC5240_XTARGET, uint32(targetPos)); err != nil {
		return err
	}

	// Ensure we're in positioning mode
	if err := t.writeRegister(TMC5240_RAMPMODE, TMC5240_MODE_POSITION); err != nil {
		return err
	}

	return nil
}

// intervalToTMCVelocity converts Klipper interval to TMC5240 velocity format
func (t *TMC5240Backend) intervalToTMCVelocity(interval uint32) uint32 {
	if interval == 0 {
		return 0
	}

	// velocity_hz = TIMER_FREQ / interval
	// Assuming TIMER_FREQ = 12MHz (12000000)
	const TIMER_FREQ = 12000000
	velocityHz := TIMER_FREQ / interval

	// TMC5240 velocity = velocity_hz * 2^24 / fCLK
	// fCLK = 12MHz for TMC5240
	tmcVel := (velocityHz * 16777216) / TMC5240_FCLK

	return tmcVel
}

// accelToTMCAccel converts Klipper acceleration to TMC5240 format
func (t *TMC5240Backend) accelToTMCAccel(accel uint32) uint32 {
	// Klipper accel: change in interval per step
	// TMC5240 accel: acceleration in Hz/s, scaled by 2^40 / (fCLK^2)
	// This is a simplified conversion - may need tuning
	// For now, use a scaling factor
	const ACCEL_SCALE = 1000
	return accel * ACCEL_SCALE
}

// GetHardwarePosition reads the current position from TMC5240
// Implements PositionMover.GetHardwarePosition
func (t *TMC5240Backend) GetHardwarePosition() (int64, error) {
	xactual, err := t.readRegister(TMC5240_XACTUAL)
	if err != nil {
		return 0, err
	}

	// XACTUAL is signed 32-bit
	t.currentPos = int64(int32(xactual))
	return t.currentPos, nil
}

// IsMoving returns true if the TMC5240 is currently executing a move
// Implements PositionMover.IsMoving
func (t *TMC5240Backend) IsMoving() bool {
	// Read RAMP_STAT register
	rampStat, err := t.readRegister(TMC5240_RAMP_STAT)
	if err != nil {
		return false
	}

	// Check VZERO bit (bit 10) - set when velocity is zero
	return (rampStat & TMC5240_RAMP_STAT_VZERO) == 0
}

// GetMoveStatus returns detailed status for debugging
// Implements PositionMover.GetMoveStatus
func (t *TMC5240Backend) GetMoveStatus() (int64, int64, uint32, uint32) {
	// Read current position
	xactual, _ := t.readRegister(TMC5240_XACTUAL)
	currentPos := int64(int32(xactual))

	// Read target position
	xtarget, _ := t.readRegister(TMC5240_XTARGET)
	targetPos := int64(int32(xtarget))

	// Read current velocity
	vactual, _ := t.readRegister(TMC5240_VACTUAL)

	// Read status flags
	rampStat, _ := t.readRegister(TMC5240_RAMP_STAT)

	return currentPos, targetPos, vactual, rampStat
}

// GetDiagnostics reads TMC5240 diagnostic information
func (t *TMC5240Backend) GetDiagnostics() (drvStatus uint32, err error) {
	return t.readRegister(TMC5240_DRV_STATUS)
}

// CheckErrors checks for TMC5240 error conditions
func (t *TMC5240Backend) CheckErrors() error {
	drvStatus, err := t.GetDiagnostics()
	if err != nil {
		return err
	}

	// Check for error conditions
	if drvStatus&TMC5240_DRV_STATUS_OT != 0 {
		return errors.New("TMC5240 overtemperature")
	}
	if drvStatus&TMC5240_DRV_STATUS_S2GA != 0 {
		return errors.New("TMC5240 short to ground phase A")
	}
	if drvStatus&TMC5240_DRV_STATUS_S2GB != 0 {
		return errors.New("TMC5240 short to ground phase B")
	}
	if drvStatus&TMC5240_DRV_STATUS_S2VSA != 0 {
		return errors.New("TMC5240 short to supply phase A")
	}
	if drvStatus&TMC5240_DRV_STATUS_S2VSB != 0 {
		return errors.New("TMC5240 short to supply phase B")
	}

	return nil
}
